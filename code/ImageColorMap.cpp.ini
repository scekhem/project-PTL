#include "ImageColorMap.h"
#include <iostream>
#include <numeric>
#include <opencv.hpp>
#include <ppl.h>
#include <concurrent_vector.h>
#include <concurrent_queue.h>
#include <ImageTypeConvert.h>
#include <MathTool.hpp>

using namespace MwALG;

static double VectLen(const double x1, const double y1)
{
	double norm = (x1 * x1) + (y1 * y1);
	return (double)sqrt(norm);
}

static double TpsBaseFunc(double r)
{
	if (r == 0.0)
		return 0.0;
	else
		return r * r * log(r);
}

static int LU_Solve(cv::Mat& A, cv::Mat& B) 
{
	if (A.rows != B.rows) return 2;
	cv::Mat X;
	bool success = cv::solve(A, B, X, cv::DECOMP_LU);
	B = X;
	return success ? 0 : 1; // 0=成功, 1=失败
}

static int GenLabelMask(const std::vector<Point>& labelPix, cv::Mat& labelImage)
{
	double fontScale = 0.5;
	int thickness = 1;
	int fontType = 0;
	std::vector<int> pointId(labelPix.size());
	std::iota(pointId.begin(), pointId.end(), 0);
	uchar* miter = (uchar*)labelImage.data;
	Concurrency::parallel_for_each(pointId.begin(), pointId.end(), [&](int i) {
		cv::circle(labelImage, cv::Point(labelPix[i].x, labelPix[i].y), 1, cv::Scalar(0), -1);
		cv::putText(labelImage, to_string(i), cv::Point(labelPix[i].x + 1, labelPix[i].y), fontType, fontScale, cv::Scalar(0), thickness);
	});
	return 0;
}

static int GenColorAxis(cv::Mat& labelAxisImage, int imageHeight, int colorType, double minValue, double maxValue)
{
	int marginWide = imageHeight * 0.05;
	int axisWide = marginWide * 0.2;
	labelAxisImage = cv::Mat::zeros(cv::Size(axisWide, imageHeight- marginWide - marginWide), CV_8UC1);
	double colorScale = 255.0 / (imageHeight - marginWide - marginWide);
	//cv::Mat colorArea = labelMat.colRange(cv::Range(10,11));
	std::vector<int> pixId(labelAxisImage.cols * labelAxisImage.rows);
	std::iota(pixId.begin(), pixId.end(), 0);
	uchar* miter = (uchar*)labelAxisImage.data;
	Concurrency::parallel_for_each(pixId.begin(), pixId.end(), [&](int i) {
		int colorValue = floor(i / labelAxisImage.cols) * colorScale;
		*(miter + i) = colorValue;
	});
	cv::applyColorMap(labelAxisImage, labelAxisImage, colorType);
	cv::copyMakeBorder(labelAxisImage, labelAxisImage, marginWide, marginWide, marginWide, marginWide + 50, 0, cv::Scalar(0,0,0));

	double fontScale = 0.5;
	int thickness = 1;
	int fontType = 0;
	cv::putText(labelAxisImage, to_string(minValue), cv::Point(marginWide + axisWide, imageHeight- marginWide), fontType, fontScale, cv::Scalar(255, 255, 255), thickness);
	cv::putText(labelAxisImage, to_string(maxValue), cv::Point(marginWide + axisWide, marginWide), fontType, fontScale, cv::Scalar(255, 255, 255), thickness);
	//labelAxisImage = labelMat;
	return 0;

}

static int GenGrayMapByHeightMap(const cv::Mat& gridMap, const cv::Mat& mask, cv::Mat& grayMap, double& minHeight, double& maxHeight)
{
	double hMax = DBL_MIN;
	double hMin = DBL_MAX;
	cv::minMaxIdx(gridMap, &hMin, &hMax);
	if (maxHeight > minHeight)
	{
		hMin = minHeight;
		hMax = maxHeight;
	}
	minHeight = hMin;
	maxHeight = hMax;

	float*  miter_grid = (float*)gridMap.data;
	uchar*  miter_mask = (uchar*)mask.data;
	uchar* miter_gray = (uchar*)grayMap.data;
	double hScale = 255.0 / (hMax - hMin);

	int pixLen = gridMap.rows * gridMap.cols;
	std::vector<int> pixId(pixLen);
	std::iota(pixId.begin(), pixId.end(), 0);
	Concurrency::parallel_for_each(pixId.begin(), pixId.end(), [&](int i) {
		if (*(miter_mask + i) > 0)
		{
			*(miter_gray + i) = (*(miter_grid + i) - hMin) * hScale;
		}
	});

	return 0;
}

static int CalcThinPlateSpline(const std::vector<MwALG::Point>& controlPoints, const std::vector<double>& measureValues, const cv::Mat& mask, cv::Mat& gridMap, cv::Mat& grayMap, double & minHeight, double & maxHeight)
{
	if (controlPoints.size() < 3)
		return -1;

	double regularization = 0.0;
	int p = controlPoints.size();

	// Allocate the matrix and vector
	cv::Mat mtx_l = cv::Mat_<double>(p + 3, p + 3);
	cv::Mat mtx_v = cv::Mat_<double>(p + 3, 1);
	cv::Mat mtx_orig_k = cv::Mat_<double>(p, p);

	// Fill K (p x p, upper left of L) and calculate
	// mean edge length from control points
	//
	// K is symmetrical so we really have to
	// calculate only about half of the coefficients.
	double* miter_k = (double*)mtx_orig_k.data;
	double* miter_l = (double*)mtx_l.data;
	double a = 0.0;
	for (int i = 0; i < p; ++i)
	{
		for (int j = i + 1; j < p; ++j)
		{
			double elen = VectLen(controlPoints[i].x - controlPoints[j].x, controlPoints[i].y - controlPoints[j].y);
			*(miter_l + i * (p + 3) + j) = *(miter_l + j * (p + 3) + i) = *(miter_k + i * p + j) = *(miter_k + j * p + i) = TpsBaseFunc(elen);
			a += elen * 2; // same for upper & lower tri
		}
	}
	a /= (double)(p * p);

	// Fill the rest of L
	miter_l = (double*)mtx_l.data;
	miter_k = (double*)mtx_orig_k.data;
	for (int i = 0; i < p; ++i)
	{
		// diagonal: reqularization parameters (lambda * a^2)
		*(miter_l + i * (p + 3) + i) = *(miter_k + i * p + i) = regularization * (a * a);

		// P (p x 3, upper right)
		*(miter_l + i * (p + 3) + p + 0) = 1.0;
		*(miter_l + i * (p + 3) + p + 1) = controlPoints[i].x;
		*(miter_l + i * (p + 3) + p + 2) = controlPoints[i].y;

		// P transposed (3 x p, bottom left)
		*(miter_l + (p + 0) * (p + 3) + i) = 1.0;
		*(miter_l + (p + 1) * (p + 3) + i) = controlPoints[i].x;
		*(miter_l + (p + 2) * (p + 3) + i) = controlPoints[i].y;
	}

	// O (3 x 3, lower right)
	for (int i = p; i < p + 3; ++i)
		for (int j = p; j < p + 3; ++j)
			mtx_l.at<double>(i, j) = 0.0;


	// Fill the right hand vector V
	double* miter_v = (double*)mtx_v.data;
	for (int i = 0; i < p; ++i)
		*(miter_v + i) = measureValues[i];
	mtx_v.at<double>(p + 0, 0) = mtx_v.at<double>(p + 1, 0) = mtx_v.at<double>(p + 2, 0) = 0.0;

	// Solve the linear system "inplace"
	if (0 != LU_Solve(mtx_l, mtx_v))
	{
		puts("Singular matrix! Aborting.");
		return -1;
	}

	// Interpolate grid heights
	double weight_a = mtx_v.at<double>(p + 0, 0);
	double weight_b = mtx_v.at<double>(p + 1, 0);
	double weight_c = mtx_v.at<double>(p + 2, 0);
	int pixLen = gridMap.rows * gridMap.cols;
	int gridWidth = gridMap.cols;
	std::vector<int> pixId(pixLen);
	std::iota(pixId.begin(), pixId.end(), 0);
	float* miter_grid = (float*)gridMap.data;
	uchar* miter_mask = (uchar*)mask.data;
	double* miter_mtxv = (double*)mtx_v.data;
	Concurrency::parallel_for_each(pixId.begin(), pixId.end(), [&](int i) {
		if (*(miter_mask + i) > 0)
		{
			int y = floor(i / gridWidth);
			int x = i % gridWidth;
			float h = weight_a + weight_b * x + weight_c * y;
			for (int i = 0; i < p; ++i)
			{
				h += *(miter_mtxv + i) * TpsBaseFunc(VectLen(controlPoints[i].x - x, controlPoints[i].y - y));
			}
			*(miter_grid + i) = h;
		}
	});

	GenGrayMapByHeightMap(gridMap, mask, grayMap, minHeight, maxHeight);

	return 0;

	// Calc bending energy
	//matrix<double> w(p, 1);
	//for (int i = 0; i < p; ++i)
	//	w(i, 0) = mtx_v(i, 0);
	//matrix<double> be = prod(prod<matrix<double> >(trans(w), mtx_orig_k), w);
	//bending_energy = be(0, 0);
}

ColorMapParams::ColorMapParams() = default;

ImageColorMap::ImageColorMap()
{
	_mapParam = ColorMapParams();
	_curHeightMap = MwImage();
	_curColorMap = MwImage();
	_measurePoints = {};
	_measureValues = {};
}

ImageColorMap::~ImageColorMap()
{
	_curHeightMap.release();
	_curColorMap.release();
}

int ImageColorMap::GenMeasurePoints(std::vector<MwALG::Point>& outputPoints, const int circleRadius , const int measureRoundNum, const bool useYTheta, int increaseNum)
{
	if ((circleRadius < 0) || (measureRoundNum < 1) || (increaseNum < 1))
	{
		// todo：更新错误码
		return -1;
	}

	int seedCore = increaseNum; // 种子数量(每圈增加点的数量)
	double radiusStep = circleRadius / measureRoundNum;

	std::vector<Point> pointYT;
	std::vector<int> roundId(measureRoundNum);
	std::iota(roundId.begin(), roundId.end(), 1);

	//// 预分配全部空间方法
	int Idsum = std::accumulate(roundId.begin(), roundId.end(), 0) * seedCore;
	pointYT.assign(Idsum + 1, Point(0, 0)); // 多加一个中心点作为第一个测量点
	std::for_each(roundId.begin(), roundId.end(), [&](int round_i) {
		int pointIDBase = seedCore * round_i * (round_i - 1) * 0.5;	// 计算等差数列和，得到当前所有的点数量，作为下标
		for (int i = 0; i < (round_i * seedCore); i++)
		{
			int pointID = pointIDBase + i + 1;
			double yValue = round_i * radiusStep;
			double tValue = i * 360.0 / (round_i * seedCore);
			pointYT[pointID].x = yValue;
			pointYT[pointID].y = tValue;
		}
	});

	//// for循环insert方法
	//std::vector<double> rValues;
	//std::vector<double> tValues;
	//rValues.push_back(0.0);
	//tValues.push_back(0.0);
	//std::for_each(roundId.begin(), roundId.end(), [&](int round_i) {
	//	int curRoundLenth = round_i * seedCore;
	//	double angelStep = 360.0 / curRoundLenth;
	//	std::vector<Point> roundPoints;
	//	roundPoints.assign(curRoundLenth, Point(round_i * radiusStep,0.0));
	//	std::vector<int> pointId(curRoundLenth);
	//	std::iota(pointId.begin(), pointId.end(), 0);
	//	std::for_each(pointId.begin(), pointId.end(), [&] (int pId) {
	//		roundPoints[pId].y = pId * 360.0 / curRoundLenth;
	//		});
	//	pointYT.insert(pointYT.end(), roundPoints.begin(), roundPoints.end());
	//});

	if (useYTheta)
	{
		outputPoints = pointYT;
		return 0;
	}

	return AxisYTheta2AxisXY(pointYT, outputPoints);
}

int ImageColorMap::AxisXY2AxisYTheta(const std::vector<MwALG::Point>& xyPoints, std::vector<MwALG::Point>& yThetaPoints)
{
	yThetaPoints.clear();
	if (xyPoints.size() < 1)
	{
		// todo：更新错误码
		return -1;
	}

	yThetaPoints.assign(xyPoints.size(), Point(0, 0));
	std::vector<int> pointId(xyPoints.size());
	std::iota(pointId.begin(), pointId.end(), 0);
	std::for_each(pointId.begin(), pointId.end(), [&](int i) {
		double rValue = sqrt(pow(xyPoints[i].x, 2) + pow(xyPoints[i].y, 2));
		double tValue = atan2(xyPoints[i].y, xyPoints[i].x);
		yThetaPoints[i].x = rValue;
		yThetaPoints[i].y = tValue;
		});

	return 0;
}

int ImageColorMap::AxisYTheta2AxisXY(const std::vector<MwALG::Point>& yThetaPoints, std::vector<MwALG::Point>& xyPoints)
{
	xyPoints.clear();
	if (yThetaPoints.size() < 1)
	{
		// todo：更新错误码
		return -1;
	}

	xyPoints.assign(yThetaPoints.size(), Point(0, 0));
	std::vector<int> pointId(yThetaPoints.size());
	std::iota(pointId.begin(), pointId.end(), 0);
	std::for_each(pointId.begin(), pointId.end(), [&](int i) {
		double xValue = yThetaPoints[i].x * cos(yThetaPoints[i].y / 180 * M_PI);
		double yValue = yThetaPoints[i].x * sin(yThetaPoints[i].y / 180 * M_PI);
		xyPoints[i].x = xValue;
		xyPoints[i].y = yValue;
	});

	return 0;
}

int ImageColorMap::AxisXY2mapXY(const std::vector<MwALG::Point>& axisPoints, std::vector<MwALG::Point>& mapPoints)
{
	mapPoints.clear();
	if (axisPoints.size() < 1)
	{
		// todo：更新错误码
		return -1;
	}
	double pointScale = _mapParam.mapSize/ 2.0 / _mapParam.waferRadius;
	double mapCenter = _mapParam.mapSize / 2.0;

	mapPoints.assign(axisPoints.size(), Point(0, 0));
	std::vector<int> pointId(axisPoints.size());
	std::iota(pointId.begin(), pointId.end(), 0);
	std::for_each(pointId.begin(), pointId.end(), [&](int i) {
		double xValue = axisPoints[i].x * pointScale + mapCenter;
		double yValue = axisPoints[i].y * pointScale + mapCenter;
		mapPoints[i].x = xValue;
		mapPoints[i].y = yValue;
		});

	return 0;
}

int ImageColorMap::MapXY2AixsXY(const std::vector<MwALG::Point>& mapPoints, std::vector<MwALG::Point>& axisPoints)
{
	axisPoints.clear();
	if (mapPoints.size() < 1)
	{
		// todo：更新错误码
		return -1;
	}
	double pointScale = _mapParam.waferRadius * 2.0 / _mapParam.mapSize;
	double mapCenter = _mapParam.mapSize / 2.0;

	axisPoints.assign(mapPoints.size(), Point(0, 0));
	std::vector<int> pointId(mapPoints.size());
	std::iota(pointId.begin(), pointId.end(), 0);
	std::for_each(pointId.begin(), pointId.end(), [&](int i) {
		double xValue = (mapPoints[i].x - mapCenter) * pointScale;
		double yValue = (mapPoints[i].y - mapCenter) * pointScale;
		axisPoints[i].x = xValue;
		axisPoints[i].y = yValue;
		});

	return 0;
}

int ImageColorMap::ConfigMap(const std::vector<MwALG::Point>& measurePoints, const bool isYTheta, const ColorMapParams& mapParams)
{
	_mapParam = mapParams;
	std::vector<MwALG::Point> controlPoints;
	if (isYTheta)
	{
		AxisYTheta2AxisXY(measurePoints, _measurePoints);
	}
	else
	{
		_measurePoints = measurePoints;
	}

	return 0;
}

MwImage ImageColorMap::GenColorMap(const std::vector<double>& measureValue)
{
	MwImage colorMap = MwImage();
	
	// 
	cv::Mat heightMap = cv::Mat::zeros(cv::Size(_mapParam.mapSize, _mapParam.mapSize), CV_32FC1);
	cv::Mat areaBase = cv::Mat::zeros(cv::Size(_mapParam.mapSize, _mapParam.mapSize), CV_8UC1);
	cv::Mat grayMap = cv::Mat::zeros(cv::Size(_mapParam.mapSize, _mapParam.mapSize), CV_8UC1);
	//cv::Mat labelMat = cv::Mat::zeros(cv::Size(_mapParam.mapSize, _mapParam.mapSize), CV_8UC3);
	cv::circle(areaBase, cv::Point(_mapParam.mapSize / 2, _mapParam.mapSize / 2), _mapParam.mapSize / 2, 1, -1);

	std::vector<MwALG::Point> controlPoints;
	AxisXY2mapXY(_measurePoints, controlPoints);

	GenLabelMask(controlPoints, areaBase);
	_areaMask = Mat2MwImage(areaBase);
	int res = CalcThinPlateSpline(controlPoints, measureValue, areaBase, heightMap, grayMap, _mapParam.colorMin, _mapParam.colorMax);
	if (res < 0)
	{
		// todo：输出异常
		return colorMap;
	}

	_curHeightMap = Mat2MwImage(heightMap);
	cv::Mat colorRes;
	cv::applyColorMap(grayMap, colorRes, _mapParam.colorType);

	std::vector<cv::Mat> channels = { areaBase, areaBase, areaBase };
	cv::Mat mergeMask;
	cv::merge(channels, mergeMask);
	cv::multiply(colorRes, mergeMask, colorRes);
	_curColorMap = Mat2MwImage(colorRes);

	// todo: 添加label和色彩轴
	cv::Mat colorAxis, resViewMat;
	GenColorAxis(colorAxis, colorRes.rows, _mapParam.colorType, _mapParam.colorMin, _mapParam.colorMax);
	cv::hconcat(std::vector<cv::Mat> { colorRes, colorAxis }, resViewMat);
	_measureValues = measureValue;
	return Mat2MwImage(resViewMat);
}

MwImage ImageColorMap::UpdateColorMap(const ColorMapParams& mapParams)
{
	/*
	更新情况分类：
	* 重新 GenColorMap 重画高度图：
		1. 图像尺寸值变化，2.wafer半径值变化；
	* 只更新色彩映射：
	    1. colorMinMax值改变，2.colorType改变；
	*/
	cv::Mat heightMap = MwImage2Mat(_curHeightMap);
	cv::Mat mask = MwImage2Mat(_areaMask);
	cv::Mat grayMap = MwImage2Mat(_curGrayMap);

	if ((_mapParam.waferRadius != mapParams.waferRadius) || (_mapParam.mapSize != mapParams.mapSize))
	{
		ConfigMap(_measurePoints, false, mapParams);
		return GenColorMap(_measureValues);
	}
	else if ((_mapParam.colorMin != mapParams.colorMin) || (_mapParam.colorMax != mapParams.colorMax))
	{

		double minVal = mapParams.colorMin;
		double maxVal = mapParams.colorMax;
		GenGrayMapByHeightMap(heightMap, mask, grayMap, minVal, maxVal);
		_curGrayMap = Mat2MwImage(grayMap);
	}

	cv::Mat colorRes;
	cv::applyColorMap(grayMap, colorRes, _mapParam.colorType);

	std::vector<cv::Mat> channels = { mask, mask, mask };
	cv::Mat mergeMask;
	cv::merge(channels, mergeMask);
	cv::multiply(colorRes, mergeMask, colorRes);
	_curColorMap = Mat2MwImage(colorRes);

	cv::Mat colorAxis, resViewMat;
	GenColorAxis(colorAxis, colorRes.rows, _mapParam.colorType, _mapParam.colorMin, _mapParam.colorMax);
	cv::hconcat(std::vector<cv::Mat> { colorRes, colorAxis }, resViewMat);
	return Mat2MwImage(resViewMat);

	_mapParam = mapParams;
	return _curColorMap;

	//MwImage colorMap = MwImage();
	//double hScale = 255.0 / (_mapParam.colorMax - _mapParam.colorMin);
	//cv::Mat gridMap = MwImage2Mat(_curHeightMap);
	//cv::Mat areaBaseGray = cv::Mat::zeros(cv::Size(_mapParam.mapSize, _mapParam.mapSize), CV_8UC1);
	//cv::circle(areaBaseGray, cv::Point(_mapParam.mapSize / 2, _mapParam.mapSize / 2), _mapParam.mapSize / 2, 255, -1);
	//float* miter_grid = (float*)gridMap.data;
	//uchar* miter_mask = (uchar*)areaBaseGray.data;
	//
	//if(hScale < 0)
	//{ 
	//	
	//}
	//
	//Concurrency::parallel_for_each(pixId.begin(), pixId.end(), [&](int i) {
	//	if (*(miter_mask + i) > 0)
	//	{
	//		*(miter_mask + i) = (*(miter_grid + i) - hMin) * hScale;
	//	}
	//});
}

MwImage ImageColorMap::curColorMap() const noexcept
{
	return _curColorMap;
}

MwImage ImageColorMap::curHeightMap() const noexcept
{
	return _curHeightMap;
}

ColorMapParams ImageColorMap::mapParam() const noexcept
{
	return _mapParam;
}
